### Perda de protensão por atrito

<p align="justify">
A perda de protensão por atrito ocorre nos cabos devido ao contato entre concreto e aço protendido. BLA BLA BLA [1]. A equação de perda por atrito emprega no módulo de perda de protensaõ da ferramenta coretectools concreto protendido é dada a seguir:
</p>    

<p align="justify">

\( Px = Pmax.e^{-u.k.a.x} \) 

Onde:<br>
</p>

<ul>
<li>\( Px \) é a carga após a perda de protensão por atrito.</li>
<li>\( Pmax \) é a carga da perda de protensão por atrito \(t\).</li>
<li>\( x_{i}^{t+1} \) é a posição da partícula \(i\) na iteração \(t+1\).</li>
<li>\( w \) é o coeficiente de inércia. Vale 1 para versão do algoritmo original.</li>
<li>\( c_1 \) é o fator de aprendizado cognitivo.</li>
<li>\( c_2 \) é o fator de aprendizadp social.</li>
<li>\( r_1 \) e \( r_2 \) são números aleatórios em entre 0 e 1.</li>
</ul>

<p align="justify">
Os fatores de aprendizagem cognitivos e social foram criados para estebalecer um balanço (em inglês <i>trade off</i> no ato da partícula caminhar pelo espaço de busca procurando a melhor solução. Kennedy e Elberthart [1<font color="red">EULLER LEMBRAR DE COLOCAR O HYPERLINK DESSE TEXTO</font>] afirmam que esses coeficientes podem variar de 0 até 4 e quando somados (\( c_1 + c_2\)) a recomendação é que totalizem o valor 4. Além desse balanço na escolha do fator \( c_1 \) e \( c_2 \) a velocidade deve ser fixada em uma faixa, semelhante as restrições laterais (\(x_{min}\) e \(x_{max}\)) nas variáveis de projeto \(x\). Tal fato de criar imposições laterais no vetor de velocidades contribui na estabilidade do método de otimização.<br>

O funcionamento do algoritmo PSO está logo abaixo:
</p>

```python
# Algoritmo em linguagem Python 3
# Declaração de dados iniciais pelo usuário
C1, C2, W, X_MIN, X_MAX, V_MIN, V_MAX
X = POP_INIT(X_MIN, X_MAX)
V = VEL_INIT(V_MIN, V_MAX)
# Avalia FO e FIT das partículas
OF = OBJ(X)
FIT = FITNESS(OF)
for I_COUNT in range(N_ITER)
    # Busca pelos valores pb e gb
    PB = PB_AVALIACAO(X, FIT)
    GB = PB_AVALIACAO(X, FIT)
    for J_COUNT in range(N_POP)
        # Atualização velocidade
        V_NEW = VELOCITY(PB, GB, X, V) 
        # Verificação de limites de velocidade
        V_NEW = LIM_VELOCITY(V_NEW, V_MIN, V_MAX)
        # Atualização da posição no espaço
        X_NEW = POSITION(X, V_NEW)
        # Verificação da posição no espaço
        X_NEW = LIM_POSITION(X_NEW, X_MIN, X_MAX)
        OF_NEW = OBJ(X_NEW)
        FIT = FITNESS(OF_NEW)
        X = X_NEW
        OF = OF_NEW
        FIT = OF_NEW
```
<p align="justify">
  Para ter acesso ao algoritmo pode clicar no <i>link</i> <a href="https://arxiv.org/ftp/arxiv/papers/1804/1804.05319.pdf">PSO AQUI VAMOS COLOCAR O ACESSO AO NOTEBOOK JUPYTER ONLINE</a>
</p>
